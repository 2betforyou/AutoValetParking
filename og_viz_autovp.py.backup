# viz_autovp.py
# -*- coding: utf-8 -*-
"""
ë‘ ì¸µ(B1, B2) = ê°™ì€ ASCII ì§€ë„ë¥¼ 'ë³µì‚¬'í•´ì„œ ë§Œë“  ë…ë¦½ ì¸µ
- ê¸€ë¡œë²Œ ì…êµ¬: B1ì˜ 'ê°€ì¥ ì™¼ìª½Â·ê°€ì¥ ìœ„' 0
- B2ë¡œ ê°€ë ¤ë©´: B1(global_entr) â†’ B1(bottom_gate=ê°€ì¥ ì™¼ìª½Â·ê°€ì¥ ì•„ë˜ 0) â†’ [ì»¤ë„¥í„°] â†’ B2(top_entr=ê°€ì¥ ì™¼ìª½Â·ê°€ì¥ ìœ„ 0)
- í†µí–‰ ê°€ëŠ¥: '0','G','R','-','|' (ëª¨ë‘ ë…¸ë“œ)
- ì—°ê²° ê·œì¹™(ì…€ ë‹¨ìœ„):
  * G/R â†”(ìˆ˜í‰) '-' ë§Œ
  * '-'  : ìˆ˜í‰ìœ¼ë¡œë§Œ ì—°ê²°(G/R/-/0/|), ìˆ˜ì§ ê¸ˆì§€
  * '|'  : ìˆ˜ì§ìœ¼ë¡œë§Œ ì—°ê²°(|/0), ìˆ˜í‰ì€ '-'ì—ë§Œ ì½”ë„ˆ í—ˆìš©
  * '0'  : ì¢Œìš° '-', ìƒí•˜ '|'
- ê²½ë¡œ íƒìƒ‰:
  * ì…ì°¨: (0|-| + ëª©í‘œ G) ì„œë¸Œê·¸ë˜í”„ì—ì„œë§Œ A*
  * ì¶œì°¨: (0|-| + ìê¸° R) ì„œë¸Œê·¸ë˜í”„ì—ì„œë§Œ A*
- ì¶©ëŒ ë°©ì§€:
  * ìŠ¤íŒŸ: pick ì§í›„ ì¦‰ì‹œ ì„ ì (claim) â†’ ì¤‘ë³µ ë°°ì • ë°©ì§€
  * ì´ë™: ì—£ì§€/ë…¸ë“œ ì‹œê°„ ì˜ˆì•½(ì‹œê°„ ê²¹ì¹¨ ê¸ˆì§€). ì¸µ ID(fid)ë¥¼ ì˜ˆì•½ í‚¤ì— í¬í•¨í•˜ì—¬ ì¸µê°„ ì¶©ëŒ ì œê±°.
- ì‹œê°í™”: B1 ìœ„ / B2 ì•„ë˜ ê²°í•© GIF (combined_twofloors.gif). ì»¤ë„¥í„°ëŠ” ì í”„ ì²˜ë¦¬.
"""

import io
import math
import random
from collections import defaultdict

import matplotlib.pyplot as plt
import networkx as nx
import simpy
from PIL import Image

# ===== íŒŒë¼ë¯¸í„° =====
random.seed(42)
EDGE_TRAVEL_TIME  = 1.0         # ì…€ 1ì¹¸ ì´ë™ ì‹œê°„(ì´ˆ)
ARRIVAL_GAP       = 2.0         # ì°¨ëŸ‰ ë„ì°© ê°„ê²©(ì´ˆ)
REPLAN_DELAY      = 3.0         # ì˜ˆì•½ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„(ì´ˆ)
PARK_TIME_RANGE   = (36, 48)    # ì‡¼í•‘ ì²´ë¥˜(ì´ˆ)
SIM_TIME          = 240.0       # ìµœëŒ€ ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ ìƒí•œ(ì´ˆ)
DT                = 1.0         # GIF í”„ë ˆì„ ìƒ˜í”Œë§ ê°„ê²©(ì´ˆ)
CONNECT_TIME      = 3.0         # B1(bottom_gate) â†” B2(top_entr) ì»¤ë„¥í„° ì†Œìš”ì‹œê°„(ì´ˆ)

# ===== í•œ ì¸µ ì§€ë„(ì´ê±¸ ê·¸ëŒ€ë¡œ ë³µì‚¬í•´ B1, B2ë¥¼ ë§Œë“­ë‹ˆë‹¤) =====
FLOOR_MAP_B1 = [
    "0-----0-----0",
    "|-R R-|-R R-|",
    "|-R G-|-R G-|",
    "|-R G-|-G G-|",
    "|-G R-|-G G-|",
    "0-----0-----0",
    "|-R R-|-R R-|",
    "|-R G-|-R G-|",
    "|-R G-|-G G-|",
    "|-R R-|-G R-|",
    "0-----0-----0",
]

FLOOR_MAP_B2 = [
    "0-----0-----0",
    "|-R R-|-R R-|",
    "|-R G-|-R G-|",
    "|-R G-|-G G-|",
    "|-G R-|-G G-|",
    "0-----0-----0",
    "|-R G-|-G R-|",
    "|-G G-|-R G-|",
    "|-G G-|-G G-|",
    "|-R G-|-G R-|",
    "0-----0-----0",
]

TRAV = set("0GR-|")  # í†µí–‰ ê°€ëŠ¥í•œ ë¬¸ì

# ===== ê·¸ë˜í”„ ë¹Œë” (ë°©í–¥ ì œì•½) =====
def build_grid_graph(lines):
    H = len(lines)
    W = max(len(r) for r in lines)
    lines = [r + " " * (W - len(r)) for r in lines]

    G = nx.Graph()
    def nid(i, j): return f"N{i}_{j}"

    # ë…¸ë“œ ìƒì„±
    for i in range(H):
        for j in range(W):
            c = lines[i][j]
            if c in TRAV:
                G.add_node(nid(i, j), ch=c, ij=(i, j))

    # ë¬¸ìÃ—ë°©í–¥ ê·œì¹™
    def can_connect(ch_from, ch_to, direction):
        if direction == 'R':  # ìˆ˜í‰
            if ch_from in {'G','R'} and ch_to == '-': return True
            if ch_from == '-' and ch_to in {'G','R','-','0','|'}: return True
            if ch_from == '0' and ch_to == '-': return True
            if ch_from == '|' and ch_to == '-': return True  # ì½”ë„ˆ
            return False
        if direction == 'D':  # ìˆ˜ì§
            if ch_from == '|' and ch_to in {'|','0'}: return True
            if ch_from == '0' and ch_to == '|': return True
            return False
        return False

    # ê°„ì„  ìƒì„± (ìš°/í•˜ë§Œ ì¶”ê°€)
    for i in range(H):
        for j in range(W):
            ch = lines[i][j]
            if ch not in TRAV: 
                continue
            u = nid(i, j)

            # ì˜¤ë¥¸ìª½
            if j+1 < W:
                chR = lines[i][j+1]
                if chR in TRAV and can_connect(ch, chR, 'R'):
                    v = nid(i, j+1)
                    G.add_edge(u, v, w=EDGE_TRAVEL_TIME)

            # ì•„ë˜
            if i+1 < H:
                chD = lines[i+1][j]
                if chD in TRAV and can_connect(ch, chD, 'D'):
                    v = nid(i+1, j)
                    G.add_edge(u, v, w=EDGE_TRAVEL_TIME)

    return G

def find_nodes(G, ch):
    return [n for n, d in G.nodes(data=True) if d.get("ch") == ch]

# ===== ê° ì¸µ ìƒì„±: B1, B2 + ì…êµ¬/ê²Œì´íŠ¸ ì‹ë³„ =====
def build_floors_from_single_map(b1, b2):
    G1 = build_grid_graph(b1)   # B1
    G2 = build_grid_graph(b2)   # B2

    # ì¢Œìƒ/ì¢Œí•˜/ìš°ìƒ/ìš°í•˜ 0 ì„ íƒê¸°
    def pick_leftmost_top_zero(Gx):
        zs = [(n, Gx.nodes[n]["ij"]) for n in find_nodes(Gx, "0")]
        if not zs: return None
        zs.sort(key=lambda x: (x[1][0], x[1][1]))
        return zs[0][0]

    def pick_leftmost_bottom_zero(Gx):
        zs = [(n, Gx.nodes[n]["ij"]) for n in find_nodes(Gx, "0")]
        if not zs: return None
        max_row = max(r for _, (r, c) in zs)
        cand = [(n, ij) for n, ij in zs if ij[0] == max_row]
        cand.sort(key=lambda x: x[1][1])
        return cand[0][0]

    # ğŸ”µ ìƒˆë¡œ ì¶”ê°€: ìš°ìƒ/ìš°í•˜ 0
    def pick_rightmost_top_zero(Gx):
        zs = [(n, Gx.nodes[n]["ij"]) for n in find_nodes(Gx, "0")]
        if not zs: return None
        min_row = min(r for _, (r, c) in zs)
        cand = [(n, ij) for n, ij in zs if ij[0] == min_row]
        cand.sort(key=lambda x: -x[1][1])   # ê°€ì¥ ì˜¤ë¥¸ìª½
        return cand[0][0]

    def pick_rightmost_bottom_zero(Gx):
        zs = [(n, Gx.nodes[n]["ij"]) for n in find_nodes(Gx, "0")]
        if not zs: return None
        max_row = max(r for _, (r, c) in zs)
        cand = [(n, ij) for n, ij in zs if ij[0] == max_row]
        cand.sort(key=lambda x: -x[1][1])   # ê°€ì¥ ì˜¤ë¥¸ìª½
        return cand[0][0]

    # ì…êµ¬/ê²Œì´íŠ¸/ì¶œêµ¬ ê³„ì‚°
    B1_top_in   = pick_leftmost_top_zero(G1)       # ê¸€ë¡œë²Œ ì…êµ¬ (í˜„í–‰ ìœ ì§€)
    B1_bot_gate = pick_leftmost_bottom_zero(G1)    # B2ë¡œ ë‚´ë ¤ê°€ëŠ” ê²Œì´íŠ¸
    B1_top_out  = pick_rightmost_top_zero(G1)      # ğŸ”µ B1 ì¶œêµ¬(ìš°ìƒ)
    B1_bot_out  = pick_rightmost_bottom_zero(G1)   # ğŸ”µ B2â†’B1 ì»¤ë„¥í„° ë„ì°©ì (ìš°í•˜)

    B2_top_in   = pick_leftmost_top_zero(G2)       # B2 ì…êµ¬(ìƒí–‰ ì»¤ë„¥í„° ë„ì°©)
    B2_top_out  = pick_rightmost_top_zero(G2)      # ğŸ”µ B2 ì¶œêµ¬(ìš°ìƒ)

    floors = {
        "B1": {
            "G": G1,
            "entr_top": B1_top_in,      # ê¸€ë¡œë²Œ ì…êµ¬(ì¢Œìƒ)
            "gate_bot": B1_bot_gate,    # B2ë¡œ ë‚´ë ¤ê°€ëŠ” ì¢Œí•˜ ê²Œì´íŠ¸
            "exit_top": B1_top_out,     # ğŸ”µ B1 ìµœì¢… ì¶œêµ¬(ìš°ìƒ)
            "exit_bot": B1_bot_out,     # ğŸ”µ B2â†’B1 ì»¤ë„¥í„° ë„ì°©(ìš°í•˜)
        },
        "B2": {
            "G": G2,
            "entr_top": B2_top_in,      # B2 ìª½ ì…êµ¬(ì¢Œìƒ)
            "exit_top": B2_top_out,     # ğŸ”µ B2 ì¶œêµ¬(ìš°ìƒ)
        }
    }
    return floors

# ===== ë¼ìš°íŒ… ì„œë¸Œê·¸ë˜í”„ =====
def build_route_subgraph(G, src=None, dst=None):
    """
    - í•­ìƒ í—ˆìš©: '0','-','|'
    - ì…ì°¨: dst(ëª©í‘œ G)ë§Œ ì¶”ê°€ í—ˆìš©
    - ì¶œì°¨: src(ìê¸° R)ë§Œ ì¶”ê°€ í—ˆìš©
    ê·¸ ì™¸ ëª¨ë“  G/Rì€ ì œì™¸ â†’ í†µê³¼ ë¶ˆê°€
    """
    base_allow = {'0','-','|'}
    allowed = set(n for n,d in G.nodes(data=True) if d['ch'] in base_allow)
    if src is not None:
        allowed.add(src)
    if dst is not None:
        allowed.add(dst)
    return G.subgraph(allowed).copy()

# ===== ê²½ë¡œ íƒìƒ‰(A*) =====
def astar_path_on(Gx, s, t):
    def xy(n): return Gx.nodes[n]["ij"]
    def h(a, b):
        (ai,aj),(bi,bj) = xy(a), xy(b)
        return abs(ai-bi)+abs(aj-bj)
    try:
        return nx.astar_path(Gx, s, t, heuristic=h, weight=lambda u,v,ed: ed.get("w", EDGE_TRAVEL_TIME))
    except nx.NetworkXNoPath:
        return None

def path_edges_with_duration(G, path_nodes):
    return [(u,v,G.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u,v in zip(path_nodes[:-1], path_nodes[1:])]

# ===== ì‹œê°„ ì˜ˆì•½ (ì—£ì§€ + ë…¸ë“œ)  â€” ì¸µID í¬í•¨í•˜ì—¬ ìŠ¤ì½”í”„ ë¶„ë¦¬ =====
class ReservationTable:
    def __init__(self):
        self.book_edge = defaultdict(list)  # (fid, ek) -> [(t0,t1,vid)]
        self.book_node = defaultdict(list)  # (fid, node) -> [(t0,t1,vid)]
        self.book_conn = []                 # ì»¤ë„¥í„° êµ¬ê°„(ì¸µê°„) -> [(t0,t1,vid)]

    @staticmethod
    def ek(u, v):
        return tuple(sorted((u, v)))

    @staticmethod
    def _ok(arr, t0, t1):
        for (a, b, _) in arr:
            if not (t1 <= a or b <= t0):
                return False
        return True

    # ì¸µ ë‚´ë¶€ ì—£ì§€/ë…¸ë“œ
    def can_use_edge(self, fid, ek, t0, t1):
        return self._ok(self.book_edge[(fid, ek)], t0, t1)

    def can_use_node(self, fid, node, t0, t1):
        return self._ok(self.book_node[(fid, node)], t0, t1)

    # ì»¤ë„¥í„° (B1â†”B2) â€” ë‹¨ì¼ ë¦¬ì†ŒìŠ¤ë¡œ ì·¨ê¸‰
    def can_use_connector(self, t0, t1):
        return self._ok(self.book_conn, t0, t1)

    # ì˜ˆì•½ ì»¤ë°‹
    def commit_edge(self, fid, ek, t0, t1, vid):
        self.book_edge[(fid, ek)].append((t0, t1, vid))

    def commit_node(self, fid, node, t0, t1, vid):
        self.book_node[(fid, node)].append((t0, t1, vid))

    def commit_connector(self, t0, t1, vid):
        self.book_conn.append((t0, t1, vid))

# ===== ê´€ì œ/ì°¨ëŸ‰ =====
class ControlTower:
    def __init__(self, env, floors):
        self.env = env
        self.floors = floors
        self.resv  = ReservationTable()
        self.traj  = {"B1": [], "B2": []}
        self.occ   = {"B1": defaultdict(list), "B2": defaultdict(list)}
        self.claimed = {"B1": set(), "B2": set()}
        # ìŠ¤íŒŸë³„ ë½ (SimPy Resource)
        self.spot_locks = {"B1": {}, "B2": {}}

        for fid, info in floors.items():
            G = info["G"]
            for n in find_nodes(G, "R"):
                self.occ[fid][n].append((0.0, math.inf))

    # ìŠ¤íŒŸ ë½ getter
    def get_spot_lock(self, fid, spot):
        Ls = self.spot_locks[fid]
        if spot not in Ls:
            Ls[spot] = simpy.Resource(self.env, capacity=1)
        return Ls[spot]

    # í›„ë³´ ìŠ¤íŒŸ
    def spot_candidates(self, fid):
        G = self.floors[fid]["G"]
        now = self.env.now
        out = []
        for sp in find_nodes(G, "G"):
            if sp in self.claimed[fid]:
                continue
            if self.is_occupied_now(fid, sp, now):
                continue
            out.append(sp)
        return out

    # ê¸€ë¡œë²Œ ì…êµ¬/ê²Œì´íŠ¸ ì ‘ê·¼ì
    @property
    def B1_global_entr(self):
        return self.floors["B1"]["entr_top"]

    @property
    def B1_bottom_gate(self):
        return self.floors["B1"]["gate_bot"]

    # @property
    # def B2_top_entr(self):
    #     return self.floors["B2"]["entr_top"]
    
    @property
    def B1_top_exit(self):
        return self.floors["B1"]["exit_top"]
    @property
    def B1_bottom_exit(self):
        return self.floors["B1"]["exit_bot"]
    @property
    def B2_top_entr(self):
        return self.floors["B2"]["entr_top"]
    @property
    def B2_top_exit(self):
        return self.floors["B2"]["exit_top"]

    # ì…ì°¨/ì¶œì°¨ìš© ë³µí•© ê²½ë¡œ ìƒì„± (ì„¸ê·¸ë¨¼íŠ¸ ë¦¬ìŠ¤íŠ¸)
    # ë°˜í™˜ í˜•ì‹: [(fid, u, v, dur), ...] + ì»¤ë„¥í„°ëŠ” ( "XFER", None, None, CONNECT_TIME ) í˜•íƒœ
    def build_composite_path_to_spot(self, fid_dest, spot):
        # ëª©ì ì§€ê°€ B1ì¸ ê²½ìš°: B1(global_entr) â†’ B1(spot)
        if fid_dest == "B1":
            G1 = self.floors["B1"]["G"]
            SG1 = build_route_subgraph(G1, src=None, dst=spot)
            p1  = astar_path_on(SG1, self.B1_global_entr, spot)
            if not p1: return None
            segs1 = [("B1", u, v, G1.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p1[:-1], p1[1:])]
            return segs1

        # ëª©ì ì§€ê°€ B2ì¸ ê²½ìš°:
        # 1) B1(global_entr) â†’ B1(bottom_gate)
        G1 = self.floors["B1"]["G"]
        SG1 = build_route_subgraph(G1, src=None, dst=self.B1_bottom_gate)
        p1  = astar_path_on(SG1, self.B1_global_entr, self.B1_bottom_gate)
        if not p1: return None
        segs1 = [("B1", u, v, G1.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p1[:-1], p1[1:])]

        # 2) [ì»¤ë„¥í„°] B1(bottom_gate) â†’ B2(top_entr)
        xfer = [("XFER", None, None, CONNECT_TIME)]

        # 3) B2(top_entr) â†’ B2(spot)
        G2 = self.floors["B2"]["G"]
        SG2 = build_route_subgraph(G2, src=None, dst=spot)
        p2  = astar_path_on(SG2, self.B2_top_entr, spot)
        if not p2: return None
        segs2 = [("B2", u, v, G2.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p2[:-1], p2[1:])]

        return segs1 + xfer + segs2

    def build_composite_path_to_exit(self, fid_src, spot):
        # B1ì—ì„œ ì¶œì°¨: spot â†’ B1 ìš°ìƒë‹¨ ì¶œêµ¬
        if fid_src == "B1":
            G1 = self.floors["B1"]["G"]
            SG1 = build_route_subgraph(G1, src=spot, dst=self.B1_top_exit)
            p1  = astar_path_on(SG1, spot, self.B1_top_exit)
            if not p1: return None
            segs1 = [("B1", u, v, G1.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p1[:-1], p1[1:])]
            return segs1

        # B2ì—ì„œ ì¶œì°¨:
        #   1) B2 spot â†’ B2 ìš°ìƒë‹¨ ì¶œêµ¬
        G2 = self.floors["B2"]["G"]
        SG2 = build_route_subgraph(G2, src=spot, dst=self.B2_top_exit)
        p2  = astar_path_on(SG2, spot, self.B2_top_exit)
        if not p2: return None
        segs2 = [("B2", u, v, G2.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p2[:-1], p2[1:])]

        #   2) [ì»¤ë„¥í„°] B2(ìš°ìƒ ì¶œêµ¬) â†’ B1(ìš°í•˜ ì¶œêµ¬ìª½ ì§„ì…ì )
        xfer = [("XFER", None, None, CONNECT_TIME)]

        #   3) B1 ìš°í•˜ë‹¨ 0 â†’ B1 ìš°ìƒë‹¨ ì¶œêµ¬
        G1 = self.floors["B1"]["G"]
        SG1 = build_route_subgraph(G1, src=self.B1_bottom_exit, dst=self.B1_top_exit)
        p1  = astar_path_on(SG1, self.B1_bottom_exit, self.B1_top_exit)
        if not p1: return None
        segs1 = [("B1", u, v, G1.edges[u, v].get("w", EDGE_TRAVEL_TIME)) for u, v in zip(p1[:-1], p1[1:])]
        return segs2 + xfer + segs1

    # ìŠ¤íŒŸ ì„ íƒ (ë‘ ì¸µ í›„ë³´ ì¤‘ ì´ ì†Œìš”ì‹œê°„ ìµœì†Œ)
    def pick_spot(self):
        best = None
        best_time = float('inf')
        for fid in ("B1", "B2"):
            G = self.floors[fid]["G"]
            for sp in self.spot_candidates(fid):
                comp = self.build_composite_path_to_spot(fid, sp)
                if not comp: 
                    continue
                total = sum(d for _,_,_,d in comp)
                if total < best_time:
                    best_time = total
                    best = (fid, sp, total)
        return best

    # ì˜ˆì•½ ìˆ˜í–‰(ë³µí•© ê²½ë¡œ). ì„±ê³µ ì‹œ ì‹œê°í™”ìš© traj ê¸°ë¡ê¹Œì§€.
    def reserve_composite(self, comp, vid, exiting=False):
        t = self.env.now
        # 1) ê°€ëŠ¥ì„± ì²´í¬
        for (fid, u, v, dur) in comp:
            t0, t1 = t, t + dur
            if fid == "XFER":
                if not self.resv.can_use_connector(t0, t1):
                    return None
            else:
                ek = ReservationTable.ek(u, v)
                if not self.resv.can_use_edge(fid, ek, t0, t1):
                    return None
                # ëª©ì  ë…¸ë“œ ì ìœ  (ë„ì°© ì§ì „/ì§í›„ margin)
                node_margin = 0.2 * dur
                if not self.resv.can_use_node(fid, v, t1 - node_margin, t1 + node_margin):
                    return None
            t = t1

        # 2) ì»¤ë°‹ + traj ê¸°ë¡
        t = self.env.now
        for (fid, u, v, dur) in comp:
            t0, t1 = t, t + dur
            if fid == "XFER":
                self.resv.commit_connector(t0, t1, vid)
                # ì‹œê°í™”: ì í”„(ë Œë” ìƒëµ). ì›í•˜ë©´ ì—°ê²° ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€ ê°€ëŠ¥.
            else:
                ek = ReservationTable.ek(u, v)
                self.resv.commit_edge(fid, ek, t0, t1, vid)
                node_margin = 0.2 * dur
                self.resv.commit_node(fid, v, t1 - node_margin, t1 + node_margin, vid)
                # traj ê¸°ë¡
                G = self.floors[fid]["G"]
                ui, uj = G.nodes[u]["ij"]; vi, vj = G.nodes[v]["ij"]
                # ì»¤ë°‹ ë£¨í”„ ë‚´ë¶€ (fid != "XFER" ì¸ ê²½ìš°) â”€ ê¸°ì¡´ append ì½”ë“œì— 'exiting' ì¶”ê°€
                self.traj[fid].append({
                    "vid": vid, "t0": t0, "t1": t1,
                    "ui": ui, "uj": uj, "vi": vi, "vj": vj,
                    "exiting": exiting 
                })
            t = t1
        return True

    # ì ìœ  êµ¬ê°„ ê´€ë¦¬
    def add_occupancy(self, fid, spot, t0, t1):
        self.occ[fid][spot].append((t0, t1))

    def is_occupied_now(self, fid, spot, t_now):
        for (a, b) in self.occ[fid].get(spot, []):
            if a <= t_now <= b:
                return True
        return False

    def try_claim(self, fid, spot, t_now):
        if self.is_occupied_now(fid, spot, t_now):
            return False
        if spot in self.claimed[fid]:
            return False
        self.claimed[fid].add(spot)
        return True

    def unclaim(self, fid, spot):
        self.claimed[fid].discard(spot)

class Vehicle:
    def __init__(self, env, vid, tower, logs):
        self.env = env
        self.vid = vid
        self.tower = tower
        self.logs = logs
        env.process(self.run())

    def L(self, msg):
        line = f"[T={self.env.now:6.1f}] car#{self.vid:<2d} {msg}"
        self.logs.append(line)
        print(line)

    def run(self):
        lock_req = None       # ğŸ”µ í˜„ì¬ ë³´ìœ  ì¤‘ì¸ ìŠ¤íŒŸ ë½
        locked_fid = None
        locked_spot = None

        try:
            # 1) ìŠ¤íŒŸ ì„ íƒ ë£¨í”„
            pick = self.tower.pick_spot()
            if not pick:
                self.L("ë°°ì • ê°€ëŠ¥í•œ ìŠ¤íŒŸ ì—†ìŒ â†’ ì¢…ë£Œ"); return
            fid, spot, _ = pick
            self.L(f"ë°°ì • ì¸µ={fid}, ìŠ¤íŒŸ={spot}")

            while True:
                # ìŠ¤íŒŸ ë½ ë¨¼ì € ìš”ì²­ (ëŒ€ê¸° ì—†ì´ ì¦‰ì‹œ or íì—ì„œ ìˆœì„œëŒ€ë¡œ ë³´ì¥)
                lock = self.tower.get_spot_lock(fid, spot)
                lock_req = lock.request()
                yield lock_req    # ìš©ëŸ‰=1 â†’ ë™ì‹œì— ë‘ ëŒ€ê°€ ì—¬ê¸°ì„œ ë™ì‹œ í†µê³¼ ë¶ˆê°€
                locked_fid, locked_spot = fid, spot

                # ì´í›„ ì„ ì (soft) â€” ì¤‘ë³µ pick ì°¨ë‹¨(ë¹ ë¥¸ ì¬íƒìƒ‰ ìœ ë„)
                if not self.tower.try_claim(fid, spot, self.env.now):
                    self.L("ìŠ¤íŒŸ ì„ ì  ì‹¤íŒ¨ â†’ ì¬íƒìƒ‰")
                    # ë½ í•´ì œ
                    lock.release(lock_req); lock_req = None; locked_fid = locked_spot = None
                    new_pick = self.tower.pick_spot()
                    if not new_pick:
                        self.L("ì¬ë°°ì • ë¶ˆê°€ â†’ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                        yield self.env.timeout(REPLAN_DELAY); continue
                    fid, spot, _ = new_pick
                    self.L(f"ì¬ë°°ì • ì¸µ={fid}, ìŠ¤íŒŸ={spot}")
                    continue

                # 2) ì…ì°¨ ê²½ë¡œ(ë³µí•©) & ì˜ˆì•½
                comp_in = self.tower.build_composite_path_to_spot(fid, spot)
                if not comp_in:
                    self.L("ì…ì°¨ ê²½ë¡œ ì—†ìŒ â†’ ì„ ì  í•´ì œ í›„ ì¬ì‹œë„")
                    self.tower.unclaim(fid, spot)
                    # ğŸ”µ ë½ í•´ì œ
                    lock.release(lock_req); lock_req = None; locked_fid = locked_spot = None
                    yield self.env.timeout(REPLAN_DELAY); continue

                ok = self.tower.reserve_composite(comp_in, self.vid)
                if not ok:
                    self.L("ì…ì°¨ ì˜ˆì•½ ì¶©ëŒ â†’ ì„ ì  í•´ì œ í›„ ëŒ€ê¸°")
                    self.tower.unclaim(fid, spot)
                    # ğŸ”µ ë½ í•´ì œ
                    lock.release(lock_req); lock_req = None; locked_fid = locked_spot = None
                    yield self.env.timeout(REPLAN_DELAY); continue

                # 3) ì´ë™
                travel = sum(d for _,_,_,d in comp_in)
                self.L(f"ì…ì°¨ ì´ë™ ì‹œì‘ (ì˜ˆìƒ {travel:.1f}s)")
                yield self.env.timeout(travel)
                break

            # 4) ì£¼ì°¨
            park_start = self.env.now
            dwell = random.randint(*PARK_TIME_RANGE)
            self.L(f"ì²´ë¥˜ ì‹œì‘ ({dwell}s)")
            G = self.tower.floors[fid]["G"]
            si, sj = G.nodes[spot]["ij"]
            self.tower.traj[fid].append({"vid": self.vid, "t0": park_start, "t1": park_start + dwell,
                                         "ui": si, "uj": sj, "vi": si, "vj": sj})
            self.tower.add_occupancy(fid, spot, park_start, park_start + dwell)
            yield self.env.timeout(dwell)

            # 5) ì¶œì°¨(ë³µí•©) & ì˜ˆì•½
            self.L("ì¶œì°¨ ìš”ì²­")
            while True:
                comp_out = self.tower.build_composite_path_to_exit(fid, spot)
                if not comp_out:
                    # ê²½ë¡œê°€ ë‹¹ì¥ ì—†ì„ ë•Œë„ ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬ ì ì´ ìœ ì§€ë˜ë„ë¡
                    wait_t0 = self.env.now
                    wait_dt = REPLAN_DELAY
                    # ì‹œê°í™”ìš© ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸(ì£¼ì°¨ì¹¸ì— ê·¸ëŒ€ë¡œ)
                    G = self.tower.floors[fid]["G"]
                    si, sj = G.nodes[spot]["ij"]
                    self.tower.traj[fid].append({
                        "vid": self.vid, "t0": wait_t0, "t1": wait_t0 + wait_dt,
                        "ui": si, "uj": sj, "vi": si, "vj": sj, "exiting": True 
                    })
                    # ì ìœ ë„ ë™ì¼ êµ¬ê°„ ì—°ì¥
                    self.tower.add_occupancy(fid, spot, wait_t0, wait_t0 + wait_dt)

                    self.L("ì¶œì°¨ ê²½ë¡œ ì—†ìŒ â†’ ì£¼ì°¨ì¹¸ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                    yield self.env.timeout(wait_dt)
                    continue

                ok = self.tower.reserve_composite(comp_out, self.vid, exiting=True)
                if not ok:
                    # ì˜ˆì•½ì´ ì•„ì§ ì•ˆ ì¡íˆë©´ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸/ì ìœ  ì—°ì¥
                    wait_t0 = self.env.now
                    wait_dt = REPLAN_DELAY
                    G = self.tower.floors[fid]["G"]
                    si, sj = G.nodes[spot]["ij"]
                    self.tower.traj[fid].append({
                        "vid": self.vid, "t0": wait_t0, "t1": wait_t0 + wait_dt,
                        "ui": si, "uj": sj, "vi": si, "vj": sj
                    })
                    self.tower.add_occupancy(fid, spot, wait_t0, wait_t0 + wait_dt)

                    self.L("ì¶œì°¨ ì˜ˆì•½ ì¶©ëŒ(ì• ë„ë¡œ ì ìœ ) â†’ ì£¼ì°¨ì¹¸ ëŒ€ê¸°")
                    yield self.env.timeout(wait_dt)
                    continue

                travel = sum(d for _, _, _, d in comp_out)
                self.L(f"ì¶œì°¨ ì´ë™ ì‹œì‘ (ì˜ˆìƒ {travel:.1f}s)")
                yield self.env.timeout(travel)
                break

            self.tower.unclaim(fid, spot)
            self.L("ê¸€ë¡œë²Œ ì…êµ¬ ë„ì°© / ìŠ¤íŒŸ í•´ì œ")

        finally:
            # ì–´ë–¤ ì´ìœ ë¡œë“  ì¢…ë£Œ ì‹œ ë½ì´ ì¡í˜€ ìˆìœ¼ë©´ ë°˜ë“œì‹œ í•´ì œ
            if lock_req is not None and locked_fid is not None and locked_spot is not None:
                self.tower.get_spot_lock(locked_fid, locked_spot).release(lock_req)

# ===== ë„ì°© í”„ë¡œì„¸ìŠ¤ =====
def arrival(env, tower, logs):
    vid = 0
    while True:
        vid += 1
        Vehicle(env, vid, tower, logs)
        yield env.timeout(ARRIVAL_GAP)

# ===== ê²°í•© GIF ë Œë” =====
def render_combined_gif(floors, traj_dict, occ_dict, sim_time, dt, out_path):
    G1 = floors["B1"]["G"]; G2 = floors["B2"]["G"]
    coords1 = [G1.nodes[n]["ij"] for n in G1.nodes]
    coords2 = [G2.nodes[n]["ij"] for n in G2.nodes]
    max_i1 = max(i for i, j in coords1)
    max_j1 = max(j for i, j in coords1)
    max_i2 = max(i for i, j in coords2)
    max_j2 = max(j for i, j in coords2)

    offset_y = max_i1 + 4  # B2ë¥¼ ì•„ë˜ë¡œ ë‚´ë¦¬ëŠ” ì˜¤í”„ì…‹
    frames = []
    t = 0.0

    while t <= sim_time + 1e-6:
        fig = plt.figure(figsize=(8, 12))
        ax = plt.gca()
        ax.set_aspect("equal")
        ax.set_xlim(-0.5, max(max_j1, max_j2) + 1.5)
        ax.set_ylim(max_i1 + max_i2 + 8, -0.5)
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_title(f"Combined Simulation (t={int(t)}s)")

        def draw_floor(G, occ, traj, offset, label):
            # íƒ€ì¼
            for n in G.nodes:
                i, j = G.nodes[n]["ij"]; base = G.nodes[n]["ch"]
                i += offset
                # ì ìœ  ìƒíƒœ(ì‹œê°„ ê¸°ë°˜)
                occupied_now = False
                if base in {"G","R"}:
                    for (a,b) in occ.get(n, []):
                        if a <= t <= b: occupied_now = True; break
                chp = "R" if occupied_now else base
                if chp == "0": fc=(0.82,0.86,1.00)
                elif chp == "G": fc=(0.85,1.00,0.85)
                elif chp == "R": fc=(1.00,0.85,0.85)
                else: fc=(1,1,1)
                ax.add_patch(plt.Rectangle((j,i),1,1,facecolor=fc,edgecolor='0.85',linewidth=0.8))
                ax.text(j+0.5,i+0.55,base,ha="center",va="center",fontsize=8,alpha=0.6)

            # ê°„ì„  (G/Rì— ë‹¿ëŠ” ê°„ì„ ì€ ê°€ë…ì„±ì„ ìœ„í•´ ìˆ¨ê¹€)
            for u,v in G.edges():
                cu,cv=G.nodes[u]["ch"],G.nodes[v]["ch"]
                if cu in {"G","R"} or cv in {"G","R"}: continue
                ui,uj=G.nodes[u]["ij"]; vi,vj=G.nodes[v]["ij"]
                ui+=offset; vi+=offset
                ax.plot([uj+0.5,vj+0.5],[ui+0.5,vi+0.5],linewidth=1.2,alpha=0.35,color="k")

            # ì°¨ëŸ‰
            for seg in traj:
                t0,t1=seg["t0"],seg["t1"]
                if t0 <= t <= t1:
                    ui,uj,vi,vj = seg["ui"],seg["uj"],seg["vi"],seg["vj"]
                    ui+=offset; vi+=offset
                    a = (t-t0)/max(1e-9,(t1-t0))
                    ci=ui+a*(vi-ui); cj=uj+a*(vj-uj)
                    # ìƒ‰ìƒ ì„ íƒ: ì¶œì°¨ í”Œë˜ê·¸ë©´ ë¹¨ê°•, ì•„ë‹ˆë©´ íŒŒë‘
                    is_exiting = bool(seg.get("exiting", False))
                    face = (1.00, 0.30, 0.30) if is_exiting else (0.20, 0.40, 1.00)
                    circ = plt.Circle((cj+0.5, ci+0.5), 0.28, alpha=0.95,
                                    facecolor=face, edgecolor="black", linewidth=0.6)
                    ax.add_patch(circ)
                    ax.text(cj+0.5, ci+0.2, f"{seg['vid']}", ha='center', va='top', fontsize=8)

            ax.text(0, offset-1.5, f"Floor {label}", fontsize=12, weight='bold', color='black')

        draw_floor(G1, occ_dict["B1"], traj_dict["B1"], 0, "B1")
        draw_floor(G2, occ_dict["B2"], traj_dict["B2"], offset_y, "B2")

        buf = io.BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        img = Image.open(buf).convert("RGBA").copy().convert("P", palette=Image.ADAPTIVE)
        buf.close(); plt.close(fig)
        frames.append(img)
        t += dt

    frames[0].save(out_path, save_all=True, append_images=frames[1:], duration=int(dt*1000), loop=0)
    print(f"[ok] saved {out_path}")

# ===== ë©”ì¸ =====
def main():
    env = simpy.Environment()
    floors = build_floors_from_single_map(FLOOR_MAP_B1, FLOOR_MAP_B2)
    tower = ControlTower(env, floors)
    logs = []
    print("=== Parking Simulation Start ===")
    env.process(arrival(env, tower, logs))
    env.run(until=SIM_TIME)
    print("=== Simulation End ===")

    # ê²°í•© GIF í•œ ì¥ë§Œ ì¶œë ¥
    render_combined_gif(
        floors, tower.traj, tower.occ,
        env.now, DT, "combined_twofloors.gif"
    )

if __name__ == "__main__":
    main()