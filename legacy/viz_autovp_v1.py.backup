# viz_autovp.py.backup
# -*- coding: utf-8 -*-
"""
ì¤‘ì•™ ê´€ì œ(ê²½ë¡œ/ì‹œê°„ ì˜ˆì•½) + SimPy ì‹œë®¬ + ì¸µë³„ ì• ë‹ˆë©”ì´ì…˜(GIF)
- í†µí–‰ ê°€ëŠ¥ ì…€: '0','G','R','-','|'  (ëª¨ë‘ ê·¸ë˜í”„ ë…¸ë“œ)
- ì—°ê²° ê·œì¹™(ì…€ ë‹¨ìœ„):
    * G/R â†”(ìˆ˜í‰) '-' ë§Œ
    * '-' â†”(ìˆ˜í‰) G/R/-/0/| , (ìˆ˜ì§) ì—°ê²° ê¸ˆì§€
    * '|' â†”(ìˆ˜ì§) |/0 , (ìˆ˜í‰) '-' ë§Œ  (ì½”ë„ˆ í—ˆìš©)
    * '0' â†” ì¢Œìš° '-' , ìƒí•˜ '|'
- ê²½ë¡œ íƒìƒ‰: ì…ì°¨ëŠ” (0|-| + ëª©í‘œ G), ì¶œì°¨ëŠ” (0|-| + ìê¸° R) ì„œë¸Œê·¸ë˜í”„
- ìƒ‰ì¹ : ì´ˆê¸° ë¬¸ìë¥¼ ë³´ì¡´í•˜ê³ , t ì‹œì ì— ì ìœ  ì¤‘ì¸ ì…€ë§Œ Rë¡œ ì¹ í•¨(í”„ë ˆì„ ì¼ê´€)
"""

import io
import math
import random
from collections import defaultdict

import matplotlib.pyplot as plt
import networkx as nx
import simpy
from PIL import Image

# ===== íŒŒë¼ë¯¸í„° =====
random.seed(42)
EDGE_TRAVEL_TIME = 1.0        # ì…€ 1ì¹¸ ì´ë™ ì‹œê°„(ì´ˆ)
ARRIVAL_GAP       = 1.0       # ì°¨ëŸ‰ ë„ì°© ê°„ê²©(ì´ˆ)
REPLAN_DELAY      = 3.0       # ì˜ˆì•½ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„(ì´ˆ)
PARK_TIME_RANGE   = (36, 48)   # ì‡¼í•‘ ì²´ë¥˜(ì´ˆ)
SIM_TIME          = 240.0     # ìµœëŒ€ ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ ìƒí•œ(ì´ˆ)
DT                = 1.0       # GIF í”„ë ˆì„ ìƒ˜í”Œë§ ê°„ê²©(ì´ˆ)

FLOOR_CATEGORY = {"B1": "food", "B2": "fashion"}

ASCII_MAP = [
    "0-----0-----0",
    "|-R R-|-R R-|",
    "|-R G-|-R G-|",
    "|-R G-|-G G-|",
    "|-G R-|-G G-|",
    "0-----0-----0",
    "|-R R-|-R R-|",
    "|-R G-|-R G-|",
    "|-R G-|-G G-|",
    "|-R R-|-G R-|",
    "0-----0-----0",
]

TRAV = set("0GR-|")  # í†µí–‰ ê°€ëŠ¥í•œ ë¬¸ì

# ===== ê·¸ë˜í”„ ë¹Œë” (ë°©í–¥ ì œì•½) =====
def build_grid_graph(lines):
    H = len(lines)
    W = max(len(r) for r in lines)
    lines = [r + " " * (W - len(r)) for r in lines]

    G = nx.Graph()
    def nid(i, j): return f"N{i}_{j}"

    # ë…¸ë“œ ìƒì„±
    for i in range(H):
        for j in range(W):
            c = lines[i][j]
            if c in TRAV:
                G.add_node(nid(i, j), ch=c, ij=(i, j))

    # ë¬¸ì Ã— ë°©í–¥ ê·œì¹™
    def can_connect(ch_from, ch_to, direction):
        # direction: 'R'(ì˜¤ë¥¸ìª½), 'D'(ì•„ë˜) â€” ë°˜ëŒ€ë°©í–¥ì€ ì¤‘ë³µ ë°©ì§€
        if direction == 'R':
            if ch_from in {'G','R'} and ch_to == '-': return True       # G/R â†’ -
            if ch_from == '-' and ch_to in {'G','R','-','0','|'}: return True  # - â†’ (ìˆ˜í‰)
            if ch_from == '0' and ch_to == '-': return True             # 0 â†’ -
            if ch_from == '|' and ch_to == '-': return True             # | â†’ - (ì½”ë„ˆ)
            return False
        if direction == 'D':
            if ch_from == '|' and ch_to in {'|','0'}: return True       # | â†’ |/0
            if ch_from == '0' and ch_to == '|': return True             # 0 â†’ |
            return False
        return False

    # ê°„ì„  ìƒì„± (ìš°/í•˜ë§Œ ì¶”ê°€)
    for i in range(H):
        for j in range(W):
            ch = lines[i][j]
            if ch not in TRAV: 
                continue
            u = nid(i, j)

            # ì˜¤ë¥¸ìª½
            if j+1 < W:
                chR = lines[i][j+1]
                if chR in TRAV and can_connect(ch, chR, 'R'):
                    v = nid(i, j+1)
                    G.add_edge(u, v)

            # ì•„ë˜
            if i+1 < H:
                chD = lines[i+1][j]
                if chD in TRAV and can_connect(ch, chD, 'D'):
                    v = nid(i+1, j)
                    G.add_edge(u, v)

    return G

def find_nodes(G, ch):
    return [n for n, d in G.nodes(data=True) if d.get("ch") == ch]

# ===== ì„œë¸Œê·¸ë˜í”„ (ì…/ì¶œì°¨ í†µí–‰ í—ˆìš© ì§‘í•© ì œí•œ) =====
def build_route_subgraph(G, src=None, dst=None):
    """
    - í•­ìƒ í—ˆìš©: '0','-','|'
    - ì…ì°¨: dst(ëª©í‘œ G)ë§Œ ì¶”ê°€ í—ˆìš©
    - ì¶œì°¨: src(ìê¸° R)ë§Œ ì¶”ê°€ í—ˆìš©
    ê·¸ ì™¸ ëª¨ë“  G/Rì€ ì œì™¸ â†’ í†µê³¼ ë¶ˆê°€
    """
    base_allow = {'0','-','|'}
    allowed = set(n for n,d in G.nodes(data=True) if d['ch'] in base_allow)
    if src is not None:
        allowed.add(src)
    if dst is not None:
        allowed.add(dst)
    return G.subgraph(allowed).copy()

# ===== ê²½ë¡œ íƒìƒ‰(A*) =====
def astar_path_on(Gx, s, t):
    def xy(n): return Gx.nodes[n]["ij"]
    def h(a, b):
        (ai,aj),(bi,bj) = xy(a), xy(b)
        return abs(ai-bi)+abs(aj-bj)
    try:
        return nx.astar_path(Gx, s, t, heuristic=h, weight=None)
    except nx.NetworkXNoPath:
        return None

def path_edges_with_duration(path_nodes):
    return [(u,v,EDGE_TRAVEL_TIME) for u,v in zip(path_nodes[:-1], path_nodes[1:])]

# ===== ì˜ˆì•½ í…Œì´ë¸” =====
class ReservationTable:
    def __init__(self):
        self.book_edge = defaultdict(list)  # edge_key -> [(t0,t1,vid)]
        self.book_node = defaultdict(list)  # node -> [(t0,t1,vid)]

    @staticmethod
    def ek(u, v): 
        return tuple(sorted((u, v)))

    def can_use_edge(self, ek, t0, t1):
        for (a, b, _) in self.book_edge[ek]:
            if not (t1 <= a or b <= t0):
                return False
        return True

    def can_use_node(self, node, t0, t1):
        for (a, b, _) in self.book_node[node]:
            if not (t1 <= a or b <= t0):
                return False
        return True

    def reserve_segments(self, segments, start_t, vid):
        """ì—£ì§€Â·ë…¸ë“œ ëª¨ë‘ ì‹œê°„ ì¶©ëŒ ê²€ì‚¬"""
        t = start_t
        temp_edges, temp_nodes = [], []
        for (u, v, dur) in segments:
            ek = self.ek(u, v)
            t0, t1 = t, t + dur
            # ì—£ì§€ ë° ëª©ì  ë…¸ë“œ ì ìœ  í™•ì¸
            if not self.can_use_edge(ek, t0, t1):
                return None
            # ë…¸ë“œ vë¥¼ t1 ê·¼ì²˜ê¹Œì§€ ì ìœ 
            node_margin = 0.2 * dur
            if not self.can_use_node(v, t1 - node_margin, t1 + node_margin):
                return None
            temp_edges.append((ek, t0, t1, (u, v)))
            temp_nodes.append((v, t1 - node_margin, t1 + node_margin))
            t = t1

        # ì¶©ëŒ ì—†ìœ¼ë©´ ì˜ˆì•½ í™•ì •
        for ek, t0, t1, _ in temp_edges:
            self.book_edge[ek].append((t0, t1, vid))
        for v, t0, t1 in temp_nodes:
            self.book_node[v].append((t0, t1, vid))
        return temp_edges

# ===== ê´€ì œ/ì°¨ëŸ‰ =====
class ControlTower:
    def __init__(self, env, floors):
        self.env = env
        self.floors = floors          # {"B1": (G, entrance), ...}
        self.resv = ReservationTable()
        self.traj = {"B1": [], "B2": []}   # ì°¨ëŸ‰ ì´ë™/ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸
        # ğŸ”´ ì ìœ  êµ¬ê°„(ì¸µë³„): spot -> [(t0,t1)]
        self.occ = {"B1": defaultdict(list), "B2": defaultdict(list)}
        self.claimed = {"B1": set(), "B2": set()}  # ìŠ¤íŒŸ ì„ ì : {(node_id), ...}

        # ì´ˆê¸° Rì€ 0~âˆ ì ìœ ë¡œ ë“±ë¡ (ì‹œì‘ ìƒ‰ ì •í™•íˆ ë°˜ì˜)
        for fid, (G, _) in floors.items():
            for n in find_nodes(G, "R"):
                self.occ[fid][n].append((0.0, math.inf))

    def spot_candidates(self, fid):
        G, _ = self.floors[fid]
        now = self.env.now
        out = []
        for sp in find_nodes(G, "G"):
            if sp in self.claimed[fid]:
                continue
            if self.is_occupied_now(fid, sp, now):
                continue
            out.append(sp)
        return out

    def pick_spot(self, pref):
        """ì¸µ ì„ í˜¸ë„ Ã— ê²½ë¡œ ê¸¸ì´ë¡œ ê°„ë‹¨ ì ìˆ˜í™”."""
        best = None
        best_score = -1e18
        for fid, (G, entr) in self.floors.items():
            w_floor = pref.get(FLOOR_CATEGORY[fid], 0.0)
            for sp in self.spot_candidates(fid):
                SG = build_route_subgraph(G, src=None, dst=sp)
                p = astar_path_on(SG, entr, sp)
                if not p: 
                    continue
                travel = (len(p)-1) * EDGE_TRAVEL_TIME
                score = -travel * w_floor + 0.1
                if score > best_score:
                    best_score = score
                    best = (fid, sp, travel)
        return best

    def reserve(self, fid, path_nodes, vid):
        G, _ = self.floors[fid]
        segs = path_edges_with_duration(path_nodes)
        details = self.resv.reserve_segments(segs, self.env.now, vid)
        if details is None:
            return None
        # ì‹œê°í™”ìš© ê¸°ë¡
        for _, t0, t1, (u, v) in details:
            ui, uj = G.nodes[u]["ij"]; vi, vj = G.nodes[v]["ij"]
            self.traj[fid].append({
                "vid": vid, "t0": t0, "t1": t1,
                "ui": ui, "uj": uj, "vi": vi, "vj": vj
            })
        return details

    # ì ìœ  êµ¬ê°„ ì¶”ê°€
    def add_occupancy(self, fid, spot, t0, t1):
        self.occ[fid][spot].append((t0, t1))
    
    
    def is_occupied_now(self, fid, spot, t_now):
        """occ í…Œì´ë¸” ê¸°ì¤€ìœ¼ë¡œ ì§€ê¸ˆ ì‹œê°ì— ì ìœ  ì¤‘ì¸ì§€ ê²€ì‚¬"""
        for (a, b) in self.occ[fid].get(spot, []):
            if a <= t_now <= b:
                return True
        return False

    def try_claim(self, fid, spot, t_now):
        """ì ìœ  ì¤‘/ì„ ì  ì¤‘ì´ë©´ ì‹¤íŒ¨, ì•„ë‹ˆë©´ ì„ ì í•˜ê³  True"""
        if self.is_occupied_now(fid, spot, t_now):
            return False
        if spot in self.claimed[fid]:
            return False
        self.claimed[fid].add(spot)
        return True

    def unclaim(self, fid, spot):
        self.claimed[fid].discard(spot)

class Vehicle:
    def __init__(self, env, vid, tower, pref, logs):
        self.env = env
        self.vid = vid
        self.tower = tower
        self.pref = pref
        self.logs = logs
        env.process(self.run())

    def L(self, msg):
        line = f"[T={self.env.now:6.1f}] car#{self.vid:<2d} {msg}"
        self.logs.append(line)
        print(line)

    def run(self):
        pick = self.tower.pick_spot(self.pref)
        if not pick:
            self.L("ë°°ì • ê°€ëŠ¥í•œ ìŠ¤íŒŸì´ ì—†ìŠµë‹ˆë‹¤. ì¢…ë£Œ")
            return

        fid, spot, _ = pick
        G, entr = self.tower.floors[fid]
        self.L(f"ë°°ì • ì¸µ={fid}, ì…êµ¬={entr}, ìŠ¤íŒŸ={spot}")

        # âœ… ì„ íƒ ì§í›„ ì¦‰ì‹œ ì„ ì  (ê²½í•© ì°¨ë‹¨)
        if not self.tower.try_claim(fid, spot, self.env.now):
            self.L("ìŠ¤íŒŸ ì„ ì  ì‹¤íŒ¨(ë™ì‹œ ê²½í•©) â†’ ì¬íƒìƒ‰")
            while True:
                new_pick = self.tower.pick_spot(self.pref)
                if not new_pick:
                    self.L("ë°°ì • ê°€ëŠ¥í•œ ìŠ¤íŒŸ ì—†ìŒ â†’ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                    yield self.env.timeout(REPLAN_DELAY)
                    continue
                fid, spot, _ = new_pick
                G, entr = self.tower.floors[fid]
                self.L(f"ì¬ë°°ì • ì¸µ={fid}, ìŠ¤íŒŸ={spot}")
                if self.tower.try_claim(fid, spot, self.env.now):
                    break
                else:
                    self.L("ì¬ë°°ì • ìŠ¤íŒŸë„ ì„ ì  ì‹¤íŒ¨ â†’ ë°˜ë³µ")

        # ì…ì°¨
        while True:
            SG_in = build_route_subgraph(G, src=None, dst=spot)
            path  = astar_path_on(SG_in, entr, spot)
            if not path:
                self.L("ì…ì°¨ ê²½ë¡œ ì—†ìŒ â†’ ì„ ì  í•´ì œ í›„ ì¬ì‹œë„")
                self.tower.unclaim(fid, spot)
                yield self.env.timeout(REPLAN_DELAY)
                # ì¬íƒìƒ‰ + ì¦‰ì‹œ ì„ ì  ì¬ì‹œë„
                while True:
                    new_pick = self.tower.pick_spot(self.pref)
                    if not new_pick:
                        self.L("ë°°ì • ê°€ëŠ¥í•œ ìŠ¤íŒŸ ì—†ìŒ â†’ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                        yield self.env.timeout(REPLAN_DELAY)
                        continue
                    fid, spot, _ = new_pick
                    G, entr = self.tower.floors[fid]
                    self.L(f"ì¬ë°°ì • ì¸µ={fid}, ìŠ¤íŒŸ={spot}")
                    if self.tower.try_claim(fid, spot, self.env.now):
                        break
                continue

            det = self.tower.reserve(fid, path, self.vid)
            if det is None:
                self.L("ì…ì°¨ ì˜ˆì•½ ì¶©ëŒ â†’ ì„ ì  í•´ì œ í›„ ëŒ€ê¸°")
                self.tower.unclaim(fid, spot)
                yield self.env.timeout(REPLAN_DELAY)
                # ì¬íƒìƒ‰ + ì¦‰ì‹œ ì„ ì  ì¬ì‹œë„
                while True:
                    new_pick = self.tower.pick_spot(self.pref)
                    if not new_pick:
                        self.L("ë°°ì • ê°€ëŠ¥í•œ ìŠ¤íŒŸ ì—†ìŒ â†’ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                        yield self.env.timeout(REPLAN_DELAY)
                        continue
                    fid, spot, _ = new_pick
                    G, entr = self.tower.floors[fid]
                    self.L(f"ì¬ë°°ì • ì¸µ={fid}, ìŠ¤íŒŸ={spot}")
                    if self.tower.try_claim(fid, spot, self.env.now):
                        break
                continue

            travel = sum(t1 - t0 for _, t0, t1, _ in det)
            self.L(f"ì…ì°¨ ì´ë™ ì‹œì‘ (ì˜ˆìƒ {travel:.1f}s)")
            yield self.env.timeout(travel)
            break

        # ì£¼ì°¨(ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸ + ì ìœ  êµ¬ê°„ ê¸°ë¡)
        park_start = self.env.now
        dwell = random.randint(*PARK_TIME_RANGE)
        self.L(f"ì²´ë¥˜ ì‹œì‘ ({dwell}s)")

        si, sj = G.nodes[spot]["ij"]
        self.tower.traj[fid].append({
            "vid": self.vid, "t0": park_start, "t1": park_start + dwell,
            "ui": si, "uj": sj, "vi": si, "vj": sj
        })
        self.tower.add_occupancy(fid, spot, park_start, park_start + dwell)
        yield self.env.timeout(dwell)

        # ì¶œì°¨
        self.L("ì¶œì°¨ ìš”ì²­")
        while True:
            SG_out = build_route_subgraph(G, src=spot, dst=entr)
            path = astar_path_on(SG_out, spot, entr)
            if not path:
                self.L("ì¶œì°¨ ê²½ë¡œ ì—†ìŒ â†’ ì¬ì‹œë„")
                yield self.env.timeout(REPLAN_DELAY); continue
            det = self.tower.reserve(fid, path, self.vid)
            if det is None:
                self.L("ì¶œì°¨ ì˜ˆì•½ ì¶©ëŒ â†’ ëŒ€ê¸°")
                yield self.env.timeout(REPLAN_DELAY); continue
            travel = sum(t1 - t0 for _, t0, t1, _ in det)
            self.L(f"ì¶œì°¨ ì´ë™ ì‹œì‘ (ì˜ˆìƒ {travel:.1f}s)")
            yield self.env.timeout(travel)
            break

        self.tower.unclaim(fid, spot) 
        self.L("ì¶œêµ¬ ë„ì°© / ìŠ¤íŒŸ í•´ì œ")

# ===== ë„ì°© í”„ë¡œì„¸ìŠ¤ =====
def arrival(env, tower, logs):
    vid = 0
    while True:
        vid += 1
        pref = {"food": 0.7, "fashion": 0.3} if vid % 2 == 1 else {"food": 0.3, "fashion": 0.7}
        Vehicle(env, vid, tower, pref, logs)
        yield env.timeout(ARRIVAL_GAP)

# ===== ë ˆì´ì•„ì›ƒ ë””ë²„ê·¸(ì„ íƒ) =====
def debug_dump_floor(fid, G):
    zeros = [(n, G.nodes[n]["ij"]) for n in find_nodes(G, "0")]
    greens = [(n, G.nodes[n]["ij"]) for n in find_nodes(G, "G")]
    reds   = [(n, G.nodes[n]["ij"]) for n in find_nodes(G, "R")]
    print(f"[{fid}] count -> 0:{len(zeros)}  G:{len(greens)}  R:{len(reds)}")
    g_row1 = [ij for _,ij in greens if ij[0]==1]
    r_row1 = [ij for _,ij in reds   if ij[0]==1]
    print(f"[{fid}] row1 G: {sorted(g_row1)}")
    print(f"[{fid}] row1 R: {sorted(r_row1)}")

def save_layout_png(fid, G, out_path):
    coords = [G.nodes[n]["ij"] for n in G.nodes]
    max_i = max(i for i, j in coords); max_j = max(j for i, j in coords)
    fig = plt.figure(figsize=(8,6)); ax = plt.gca()
    ax.set_aspect("equal")
    ax.set_xlim(-0.5, max_j + 1.5); ax.set_ylim(max_i + 1.5, -0.5)
    ax.set_xticks([]); ax.set_yticks([]); ax.set_title(f"{fid} layout t=0")

    for n in G.nodes:
        i, j = G.nodes[n]["ij"]; ch = G.nodes[n]["ch"]
        if ch == "0": fc=(0.82,0.86,1.00)
        elif ch == "G": fc=(0.85,1.00,0.85)
        elif ch == "R": fc=(1.00,0.85,0.85)
        else: fc=(1,1,1)
        ax.add_patch(plt.Rectangle((j,i),1,1,facecolor=fc,edgecolor='0.85',linewidth=0.8))
        ax.text(j+0.5, i+0.55, ch, ha="center", va="center", fontsize=8, alpha=0.85)

    # G/Rì— ë‹¿ëŠ” ê°„ì„ ì€ ìƒëµ(ì‹œê°ì ìœ¼ë¡œ ASCIIì™€ ë” ìœ ì‚¬)
    for u, v in G.edges():
        cu = G.nodes[u]["ch"]; cv = G.nodes[v]["ch"]
        if cu in {"G","R"} or cv in {"G","R"}: 
            continue
        ui, uj = G.nodes[u]["ij"]; vi, vj = G.nodes[v]["ij"]
        ax.plot([uj+0.5, vj+0.5], [ui+0.5, vi+0.5], linewidth=1.2, alpha=0.35, color="k")

    fig.savefig(out_path, bbox_inches="tight"); plt.close(fig)
    print(f"[ok] saved {out_path}")

# ===== ì‹œê°í™” =====
def render_floor_gif(fid, floor, segments, sim_time, dt, out_path, occ=None):
    G, entr = floor
    coords = [G.nodes[n]["ij"] for n in G.nodes]
    max_i = max(i for i, j in coords); max_j = max(j for i, j in coords)

    frames = []
    t = 0.0
    while t <= sim_time + 1e-6:
        fig = plt.figure(figsize=(8, 6)); ax = plt.gca()
        ax.set_aspect("equal")
        ax.set_xlim(-0.5, max_j + 1.5); ax.set_ylim(max_i + 1.5, -0.5)
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_title(f"{fid}  t={int(t)}s")

        # íƒ€ì¼ (0/G/Rë§Œ ìƒ‰) â€” chëŠ” ì´ˆê¸°ë¬¸ì, occë¡œ t ì‹œì  ì ìœ  ë°˜ì˜
        for n in G.nodes:
            i, j = G.nodes[n]["ij"]
            base = G.nodes[n]["ch"]
            # t ì‹œì  ì ìœ  ì—¬ë¶€
            occupied_now = False
            if base in {"G","R"} and occ is not None:
                for (a, b) in occ.get(n, []):
                    if a <= t <= b:
                        occupied_now = True
                        break
            ch_for_paint = "R" if occupied_now else base

            if ch_for_paint == "0":    fc=(0.82,0.86,1.00)
            elif ch_for_paint == "G":  fc=(0.85,1.00,0.85)
            elif ch_for_paint == "R":  fc=(1.00,0.85,0.85)
            else:                      fc=(1,1,1)
            ax.add_patch(plt.Rectangle((j,i),1,1,facecolor=fc,edgecolor='0.85',linewidth=0.8))
            ax.text(j+0.5, i+0.55, base, ha="center", va="center", fontsize=8, alpha=0.6)

        # í†µë¡œì„ : G/Rì— ë‹¿ëŠ” ê°„ì„ ì€ ìˆ¨ê¹€(ì‹œì‘ í”„ë ˆì„ ê°€ë…ì„±)
        for u, v in G.edges():
            cu = G.nodes[u]["ch"]; cv = G.nodes[v]["ch"]
            if cu in {"G","R"} or cv in {"G","R"}:
                continue
            ui, uj = G.nodes[u]["ij"]; vi, vj = G.nodes[v]["ij"]
            ax.plot([uj+0.5, vj+0.5], [ui+0.5, vi+0.5], linewidth=1.2, alpha=0.35, color="k")

        # ì°¨ëŸ‰ (ì´ë™ + ì •ì§€ ì„¸ê·¸ë¨¼íŠ¸)
        for seg in segments:
            t0, t1 = seg["t0"], seg["t1"]
            if t0 <= t <= t1:
                ui, uj, vi, vj = seg["ui"], seg["uj"], seg["vi"], seg["vj"]
                a = (t - t0) / max(1e-9, (t1 - t0))
                ci = ui + a*(vi-ui); cj = uj + a*(vj-uj)
                circ = plt.Circle((cj+0.5, ci+0.5), 0.28, alpha=0.95,
                                  facecolor=(0.20,0.40,1.00), edgecolor="black", linewidth=0.6)
                ax.add_patch(circ)
                ax.text(cj+0.5, ci+0.2, f"{seg['vid']}", ha='center', va='top', fontsize=8)

        # í”„ë ˆì„ ìº¡ì²˜
        buf = io.BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        img = Image.open(buf).convert("RGBA").copy().convert("P", palette=Image.ADAPTIVE)
        buf.close(); plt.close(fig)
        frames.append(img)
        t += dt

    if not frames:
        fig = plt.figure(figsize=(6,6)); plt.title(f"{fid} (no frames)")
        buf = io.BytesIO(); plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0); img0 = Image.open(buf).convert("RGBA").copy().convert("P", palette=Image.ADAPTIVE)
        buf.close(); plt.close(fig); frames.append(img0)

    frames[0].save(out_path, save_all=True, append_images=frames[1:], duration=int(dt*1000), loop=0)

def render_combined_gif(floors, traj_dict, occ_dict, sim_time, dt, out_path):
    """B1, B2ë¥¼ ìœ„/ì•„ë˜ë¡œ ê²°í•©í•œ í•˜ë‚˜ì˜ GIF ìƒì„±"""
    G1, _ = floors["B1"]
    G2, _ = floors["B2"]
    coords1 = [G1.nodes[n]["ij"] for n in G1.nodes]
    coords2 = [G2.nodes[n]["ij"] for n in G2.nodes]
    max_i1 = max(i for i, j in coords1)
    max_j1 = max(j for i, j in coords1)
    max_i2 = max(i for i, j in coords2)
    max_j2 = max(j for i, j in coords2)
    
    offset_y = max_i1 + 4  # B2ë¥¼ ì•„ë˜ë¡œ ë‚´ë¦¬ëŠ” ì˜¤í”„ì…‹
    frames = []
    t = 0.0

    while t <= sim_time + 1e-6:
        fig = plt.figure(figsize=(8, 12))
        ax = plt.gca()
        ax.set_aspect("equal")
        ax.set_xlim(-0.5, max(max_j1, max_j2) + 1.5)
        ax.set_ylim(max_i1 + max_i2 + 8, -0.5)
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_title(f"Combined Simulation (t={int(t)}s)")

        def draw_floor(G, occ, traj, offset, label):
            for n in G.nodes:
                i, j = G.nodes[n]["ij"]
                i += offset
                base = G.nodes[n]["ch"]
                occupied_now = False
                if base in {"G","R"}:
                    for (a,b) in occ.get(n, []):
                        if a <= t <= b:
                            occupied_now = True
                            break
                chp = "R" if occupied_now else base
                if chp == "0": fc=(0.82,0.86,1.00)
                elif chp == "G": fc=(0.85,1.00,0.85)
                elif chp == "R": fc=(1.00,0.85,0.85)
                else: fc=(1,1,1)
                ax.add_patch(plt.Rectangle((j,i),1,1,facecolor=fc,edgecolor='0.85',linewidth=0.8))
                ax.text(j+0.5,i+0.55,base,ha="center",va="center",fontsize=8,alpha=0.6)

            for u,v in G.edges():
                cu,cv=G.nodes[u]["ch"],G.nodes[v]["ch"]
                if cu in {"G","R"} or cv in {"G","R"}: continue
                ui,uj=G.nodes[u]["ij"]; vi,vj=G.nodes[v]["ij"]
                ui+=offset; vi+=offset
                ax.plot([uj+0.5,vj+0.5],[ui+0.5,vi+0.5],linewidth=1.2,alpha=0.35,color="k")
            
            # ì°¨ëŸ‰
            for seg in traj:
                t0,t1=seg["t0"],seg["t1"]
                if t0 <= t <= t1:
                    ui,uj,vi,vj = seg["ui"],seg["uj"],seg["vi"],seg["vj"]
                    ui+=offset; vi+=offset
                    a = (t-t0)/max(1e-9,(t1-t0))
                    ci=ui+a*(vi-ui); cj=uj+a*(vj-uj)
                    circ=plt.Circle((cj+0.5,ci+0.5),0.28,alpha=0.95,
                                    facecolor=(0.20,0.40,1.00),edgecolor="black",linewidth=0.6)
                    ax.add_patch(circ)
                    ax.text(cj+0.5,ci+0.2,f"{seg['vid']}",ha='center',va='top',fontsize=8)
            
            ax.text(0, offset-1.5, f"Floor {label}", fontsize=12, weight='bold', color='black')

        draw_floor(G1, occ_dict["B1"], traj_dict["B1"], 0, "B1")
        draw_floor(G2, occ_dict["B2"], traj_dict["B2"], offset_y, "B2")

        buf = io.BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        img = Image.open(buf).convert("RGBA").copy().convert("P", palette=Image.ADAPTIVE)
        buf.close(); plt.close(fig)
        frames.append(img)
        t += dt

    frames[0].save(out_path, save_all=True, append_images=frames[1:], duration=int(dt*1000), loop=0)
    print(f"[ok] saved {out_path}")
    
# ===== ë©”ì¸ =====
def build_floors():
    G1 = build_grid_graph(ASCII_MAP)
    G2 = build_grid_graph(ASCII_MAP)

    # ì¢Œ/ìš° ìµœìƒë‹¨ '0'ì„ entranceë¡œ
    def pick_leftmost_zero(G):
        zs = [(n, G.nodes[n]["ij"]) for n in find_nodes(G, "0")]
        zs.sort(key=lambda x: (x[1][0], x[1][1]))
        return zs[0][0] if zs else None

    def pick_rightmost_zero(G):
        zs = [(n, G.nodes[n]["ij"]) for n in find_nodes(G, "0")]
        zs.sort(key=lambda x: (x[1][0], -x[1][1]))
        return zs[0][0] if zs else None

    B1_entr = pick_leftmost_zero(G1)
    B2_entr = pick_rightmost_zero(G2)
    return {"B1": (G1, B1_entr), "B2": (G2, B2_entr)}

def arrival_process(env, tower, logs):
    env.process(arrival(env, tower, logs))

def main():
    env = simpy.Environment()
    floors = build_floors()

    # ì‹œì‘ Map ë ˆì´ì•„ì›ƒ ìŠ¤ëƒ…ìƒ·
    # for fid, (G, _) in floors.items():
    #     debug_dump_floor(fid, G)
    #     save_layout_png(fid, G, out_path=f"{fid}_layout_debug.png")

    tower = ControlTower(env, floors)
    logs = []
    logs.append(f"[T={env.now:6.1f}] [TOWER] ì´ˆê¸° R={sum(len(find_nodes(G,'R')) for G,_ in floors.values())}, ì´ˆê¸° G={sum(len(find_nodes(G,'G')) for G,_ in floors.values())}")
    arrival_process(env, tower, logs)

    print("=== Parking Simulation Start ===")
    env.run(until=SIM_TIME)
    print("=== Simulation End ===")
    
    render_combined_gif(floors, tower.traj, tower.occ, env.now, DT, "combined_simulation.gif")

    # GIF ìƒì„± (ì ìœ êµ¬ê°„ ì „ë‹¬)
    # for fid, floor in floors.items():
    #     out_path = f"{fid}_simulation.gif"
    #     render_floor_gif(fid, floor, tower.traj[fid], env.now, DT, out_path, occ=tower.occ[fid])
    #     print(f"[ok] saved {out_path}")

if __name__ == "__main__":
    main()


